! (C) Copyright 2015- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

#:mute
#:set config_file = os.path.dirname(os.path.abspath(_THIS_FILE_)) + '/radintg_config.yaml'
#:set config = field_config.VariableConfiguration(config_file)
#:set zrgp = config.groups['ZRGP']
#:set variables = zrgp.variables
#:endmute

#:set var_dims = { &
&     2: [idx for idx, v in enumerate(variables) if v.dimension[0] == 1], &
&     3: [idx for idx, v in enumerate(variables) if v.dimension[0] != 1] &
& }


#:set arg_list = [ &
&     'iamu0', 'its', 'iald', 'ialp', 'iemiss', 'iccnl', 'iccno', &
&     'igelam', 'igemu', 'islm', 'ipr', 'iti', 'iaprs', 'ihti', &
&     'iwv', 'iico2', 'iich4', 'iin2o', 'ino2', 'ic11', 'ic12', &
&     'ic22', 'icl4', 'ioz', 'iclc', 'ilwa', 'iiwa', 'irwa', &
&     'iswa', 'iaer', 'iaero', 'ifrso', 'ifrth', 'iswfc', 'ilwfc', &
&     'ifrsod', 'ifrted', 'ifrsodc', 'ifrtedc', 'ifdir', 'icdir', &
&     'isudu', 'iuvdf', 'iparf', 'iparcf', 'itincf', 'iemit', &
&     'ilwderivative', 'iswdiffuseband', 'iswdirectband', &
& ]
#:set opt_arg_list = [ 'ire_liq', 'ire_ice', 'ioverlap' ]
#:set arg_idx = { &
&     v.name: idx for idx, v in enumerate(variables) &
&     if v.name in arg_list + opt_arg_list&
& }

MODULE RADIATION_SCHEME_LAYER_MOD

IMPLICIT NONE

CONTAINS

SUBROUTINE RADIATION_SCHEME_LAYER &
     & (YRADIATION, ZRGP_FIELDS, NGPTOT, NPROMA, NFLEVG, KAEROSOL, &
     &  PSOLAR_IRRADIANCE, IVERBOSE, &
     ! OPTIONAL ARGUMENT for bit-identical results in tests
     &  ISEED)

USE FIELD_MODULE   , ONLY : FIELD_2RB, FIELD_3RB
USE FIELD_FACTORY_MODULE

! Modules from ifs or ifsaux libraries
USE PARKIND1                , ONLY : JPIM, JPRB, JPRD
USE YOMHOOK                 , ONLY : LHOOK, DR_HOOK, JPHOOK
USE RADIATION_SETUP         , ONLY : TRADIATION
USE RADIATION_IO            , ONLY : NULERR
USE IFS_BLOCKING            , ONLY : RADINTG_ZRGP_TYPE
USE RADIATION_FIELD_TYPE_MODULE,    ONLY : SINGLE_LEVEL_FIELD_TYPE,    &
                                         & THERMODYNAMICS_FIELD_TYPE,  &
                                         & GAS_FIELD_TYPE,             &
                                         & CLOUD_FIELD_TYPE

! Modules from radiation
USE RADIATION_SINGLE_LEVEL,         ONLY: SINGLE_LEVEL_TYPE
USE RADIATION_THERMODYNAMICS,       ONLY: THERMODYNAMICS_TYPE
USE RADIATION_GAS,                  ONLY: GAS_TYPE
USE RADIATION_CLOUD,                ONLY: CLOUD_TYPE

IMPLICIT NONE

! INPUT ARGUMENTS

TYPE(TRADIATION), INTENT(IN)    :: YRADIATION
TYPE(RADINTG_ZRGP_TYPE), INTENT(INOUT) :: ZRGP_FIELDS

! *** Array dimensions and ranges
INTEGER(KIND=JPIM),INTENT(IN)   :: NGPTOT   ! Number of columns
INTEGER(KIND=JPIM),INTENT(IN)   :: NPROMA   ! Number of columns
INTEGER(KIND=JPIM),INTENT(IN)   :: NFLEVG   ! Number of levels
INTEGER(KIND=JPIM),INTENT(IN)   :: KAEROSOL ! Number of aerosol types

! *** Single-level fields
REAL(KIND=JPRB),   INTENT(IN)   :: PSOLAR_IRRADIANCE ! (W m-2)

INTEGER,           INTENT(IN)   :: IVERBOSE

! Optional input argument (Added for validating against ecrad standalone!)
INTEGER,           INTENT(IN), OPTIONAL :: ISEED(:,:)

INTEGER(KIND=JPIM) :: KIDIA, KFDIA, IBL, JKGLO, NBLKS

! Single level field type and type
TYPE(SINGLE_LEVEL_FIELD_TYPE) :: SINGLE_LEVEL_FIELD
TYPE(SINGLE_LEVEL_TYPE) :: SINGLE_LEVEL
TYPE(THERMODYNAMICS_FIELD_TYPE) :: THERMODYNAMICS_FIELD
TYPE(THERMODYNAMICS_TYPE) :: THERMODYNAMICS
TYPE(GAS_FIELD_TYPE) :: GAS_FIELD
TYPE(GAS_TYPE) :: GAS
TYPE(CLOUD_FIELD_TYPE) :: YLCLOUD_FIELD
TYPE(CLOUD_TYPE) :: YLCLOUD
TYPE(AEROSOL_FIELD_TYPE) :: AEROSOL_FIELD
TYPE(AEROSOL_TYPE) :: AEROSOL
TYPE(FLUX_FIELD_TYPE) :: FLUX_FIELD
TYPE(FLUX_TYPE) :: FLUX

! Field pointers for each field in ZRGP
#:for d in var_dims
#:for d_idx, idx in enumerate(var_dims[d])
#:set v = variables[idx]
CLASS(FIELD_${d}$RB), POINTER :: PFIELD_${v.name}$ => NULL()
REAL(KIND=JPRB), POINTER, CONTIGUOUS :: P_${v.name}$(${','.join([':'] * (d-1))}$) => NULL()
#:endfor
#:endfor

#include "radiation_scheme.intfb.h"

#:for idx, v in enumerate(variables)
IF(${v.condition}$) THEN ! ${v.name}$
  CALL GET_STACK_MEMBER(ZRGP_FIELDS%FIELD_WRAPPER, ${idx+1}$, PFIELD_${v.name}$)
  CALL PFIELD_${v.name}$%SYNC_HOST_RDWR()
END IF
#:endfor


NBLKS = (NGPTOT-1)/NPROMA + 1
CALL SINGLE_LEVEL_FIELD%INIT(NBLKS, NPROMA, YRADIATION%YRERAD%NSW, YRADIATION%YRERAD%NLWEMISS, &
     &                      USE_SW_ALBEDO_DIRECT=.TRUE.)
CALL THERMODYNAMICS_FIELD%INIT(NBLKS, NPROMA, NFLEVG, USE_H2O_SAT=.TRUE.)
CALL GAS_FIELD%INIT(NBLKS, NPROMA, NFLEVG)
CALL YLCLOUD_FIELD%INIT(NBLKS, NPROMA, NFLEVG, FRAC_STD=YRADIATION%YRERAD%RCLOUD_FRAC_STD)
IF (YRADIATION%YRERAD%NAERMACC == 1) THEN
  CALL AEROSOL_FIELD%INIT(NBLKS, NPROMA, 1, NFLEVG, KAEROSOL) ! MACC aerosols
ELSE
  CALL AEROSOL_FIELD%INIT(NBLKS, NPROMA, 1, NFLEVG, 6) ! Tegen climatology
ENDIF
CALL FLUX_FIELD%INIT(NBLKS, YRADIATION%RAD_CONFIG, 1, NPROMA, NFLEVG)

!$OMP PARALLEL DO SCHEDULE(DYNAMIC,1)&
!$OMP& PRIVATE(JKGLO,KIDIA,KFDIA,IBL) FIRSTPRIVATE(ZRGP_FIELDS, &
!$OMP& SINGLE_LEVEL_FIELD, SINGLE_LEVEL, &
!$OMP& THERMODYNAMICS_FIELD, THERMODYNAMICS, &
!$OMP& GAS_FIELD, GAS, &
!$OMP& YLCLOUD_FIELD, YLCLOUD, &
!$OMP& AEROSOL_FIELD, AEROSOL, &
!$OMP& FLUX_FIELD, FLUX)
DO JKGLO=1,NGPTOT,NPROMA
    KIDIA=1
    KFDIA=MIN(NPROMA,NGPTOT-JKGLO+1)
    IBL=(JKGLO-1)/NPROMA+1

    ! Update radiation field type view pointers
    CALL SINGLE_LEVEL_FIELD%UPDATE_VIEW(IBL)
    CALL SINGLE_LEVEL_FIELD%UPDATE_SINGLE_LEVEL(SINGLE_LEVEL)
    CALL THERMODYNAMICS_FIELD%UPDATE_VIEW(IBL)
    CALL THERMODYNAMICS_FIELD%UPDATE_THERMODYNAMICS(THERMODYNAMICS)
    CALL GAS_FIELD%UPDATE_VIEW(IBL)
    CALL GAS_FIELD%UPDATE_GAS(GAS)
    CALL YLCLOUD_FIELD%UPDATE_VIEW(IBL)
    CALL YLCLOUD_FIELD%UPDATE_CLOUD(YLCLOUD)
    CALL AEROSOL_FIELD%UPDATE_VIEW(IBL)
    CALL AEROSOL_FIELD%UPDATE_AEROSOL(AEROSOL)
    CALL FLUX_FIELD%UPDATE_VIEW(IBL)
    CALL FLUX_FIELD%UPDATE_FLUX(FLUX)

    ! Create contiguous view pointers for each field in the current block
    #:for d in var_dims
    #:for d_idx, idx in enumerate(var_dims[d])
    #:set v = variables[idx]
    IF ( ${v.condition}$ ) P_${v.name}$ => PFIELD_${v.name}$%GET_VIEW(IBL)
    #:endfor
    #:endfor

    ! Call the ECRAD radiation scheme
    CALL RADIATION_SCHEME &
        & (YRADIATION, &
        &  KIDIA, KFDIA, NPROMA, &                       ! startcol, endcol, ncol
        &  NFLEVG, KAEROSOL, &
        &  PSOLAR_IRRADIANCE &                               ! solar_irrad
    #:for arg in arg_list
        &, P_${arg}$ &
    #:endfor
        &, SINGLE_LEVEL &
        &, THERMODYNAMICS &
        &, GAS &
        &, YLCLOUD &
        &, AEROSOL &
        &, FLUX &
#ifdef BITIDENTITY_TESTING
        ! To validate results against standalone ecrad, we overwrite effective
        ! radii, cloud overlap and seed with input values
        &, pre_liq=p_ire_liq, pre_ice=p_ire_ice &
        &, pcloud_overlap=p_ioverlap, iseed=iseed(:,ibl) &
#endif
        & )

end do
!$OMP END PARALLEL DO

CALL SINGLE_LEVEL_FIELD%FINAL()
CALL THERMODYNAMICS_FIELD%FINAL()
CALL GAS_FIELD%FINAL()
CALL YLCLOUD_FIELD%FINAL()
CALL AEROSOL_FIELD%FINAL()
CALL FLUX_FIELD%FINAL()


END SUBROUTINE RADIATION_SCHEME_LAYER

END MODULE RADIATION_SCHEME_LAYER_MOD
